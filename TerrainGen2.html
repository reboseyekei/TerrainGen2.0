<!DOCTYPE html>
<html>
<head>
	<canvas id="world" width="1000" height="1000" ></canvas>
</head>
<body>
	<script>
		var c = document.getElementById("world");
		var ctx = c.getContext("2d");
		const MAPSIZE = 500;
		var map = new Array(MAPSIZE);
		const CONTSIZE = 100;
		var points = 1;
		var steepness = 0.01;
		
		
		//Classes: -----------------
		function Tile()
		{
			this.type = 'w';
			this.elevation = 0;
		}
		function Interface()
		{
			this.zoom = 0;
			this.yView = 0;
			this.xView = 0;
		}
		//End Classes--------------
		
		var pView = new Interface();
		
		for(i = 0; i < MAPSIZE; i++){
			map[i] = new Array(MAPSIZE);
			for(j = 0; j < MAPSIZE; j++){
				map[i][j] = new Tile();
			}
		}
		
		
		function drawEntireMap()
		{
			for(i = 0; i < MAPSIZE; i++){
				for(j = 0; j < MAPSIZE; j++){
					if(map[i][j].elevation <= 0)
					{
						ctx.fillStyle = "blue";
					}
					else if(map[i][j].elevation < .4){
						ctx.fillStyle = "green";	
					}
					else if(map[i][j].elevation < .6){
						ctx.fillStyle = "olive";
					}
					else if(map[i][j].elevation < .8){
						ctx.fillStyle = "grey";
					}
					else{
						ctx.fillStyle = "white";
					}
					ctx.fillRect(j*1, i*1, 1, 1);
				}
			}
		}

		{
			var zoom = 20-pView.zoom;
			for(i = pView.yView; i < pView.yView + 20; i++){
				for(j = pView.xView; j < pView.xView + 20; j++){
					ctx.fillStyle = "blue";
					ctx.fillRect(j*zoom, i*zoom, 1*zoom, 1*zoom);
				}
			}
		}
		function safeC(a)
		{
			if(a >= MAPSIZE){ return a - MAPSIZE; }
			if(a < 0){ return MAPSIZE + a; }
			return a;
		}
		function getDist(y1, x1, y2, x2)
		{
			var dx = Math.abs(x2 - x1);
			var dy = Math.abs(y2 - y1);
			if (dx > MAPSIZE/2){
				dx = MAPSIZE - dx;
			}
			if (dy > MAPSIZE/2){
				dy = MAPSIZE - dy;
			}
			return Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
		}
		function genLand()
		{
			var centerPoints = new Array(Math.floor(Math.random() * 8) + 2);
			centerPoints[0] = [ Math.floor(Math.random() * MAPSIZE - 300) + 300, Math.floor(Math.random() * MAPSIZE - 300) + 300];
			map[safeC(centerPoints[0][1])][safeC(centerPoints[0][1])].elevation = 1;
			for(i=1; i < centerPoints.length; i++)
			{
				centerPoints[i] = [];
				centerPoints[i][0] = safeC(Math.floor(Math.random() * (10*centerPoints.length)) + (centerPoints[i-1][0] - 5*centerPoints.length));
				centerPoints[i][1] = safeC(Math.floor(Math.random() * (10*centerPoints.length)) + (centerPoints[i-1][1] - 5*centerPoints.length));
				map[safeC(centerPoints[i][0])][safeC(centerPoints[i][1])].elevation = 1;
			}
			var centerPoint = [0, 0]; //x y
			for(j = 0; j < centerPoints.length; j++)
			{
				centerPoint[0] += centerPoints[j][0]/centerPoints.length;
				centerPoint[1] += centerPoints[j][1]/centerPoints.length;
			}
			centerPoint[0] = safeC(Math.round(centerPoint[0]));
			centerPoint[1] = safeC(Math.round(centerPoint[1]));
			map[safeC(centerPoint[0])][safeC(centerPoint[1])].elevation = 1;
			//Gen Mountains and Elevated Areas near central points
			for(j = 0; j < 2; j++){
				for(i = 0; i < centerPoints.length; i++)
				{
					var mSize = 10*centerPoints.length;
					var banDir = Math.floor(Math.random() * 4);
					if(j == 1){
						banDir = -1;
					}
					var dir = 0;
					var lastDir = -1;
					var xC = Math.floor(Math.random() * (10*centerPoints.length)) + (centerPoints[i][0] - 5*centerPoints.length);
					var yC = Math.floor(Math.random() * (10*centerPoints.length)) + (centerPoints[i][1] - 5*centerPoints.length);
					while(mSize > 0)
					{
						do{
							dir = Math.floor(Math.random() * 4);
						}while(dir == banDir || dir == lastDir);
						if(Math.random() > .3)
						{
							map[safeC(yC)][safeC(xC)].elevation = 2;
						}
						if(dir == 0) 
							yC++; 
						if(dir == 1)
							xC++;
						if(dir == 2) 
							yC--;
						if(dir == 3)
							xC--; 
						if(j == 0){
							if(dir < 2){lastDir = dir + 2; }
							else{lastDir = dir - 2; }
						}
						mSize--;
					}
				}
			}
			//Fill in areas toward center of island
			for(h = 0; h < centerPoints.length; h++)
			{
				for(i = centerPoints[h][1] - centerPoints.length*10; i < centerPoints[h][1] + centerPoints.length * 10; i++)
				{
					for(j = centerPoints[h][0] - centerPoints.length * 10; j < centerPoints[h][0] + centerPoints.length*10; j++)
					{
						if(map[safeC(i)][safeC(j)].elevation > 0 && Math.random() < 2*map[safeC(i)][safeC(j)].elevation )
						{
							if(safeC(i) < centerPoint[1]) //Above
							{
								if(map[safeC(i+1)][safeC(j)].elevation <= .8)
								{
									console.log("hi");
									map[safeC(i+1)][safeC(j)].elevation = .2;
								}
							}
							else if(safeC(i) > centerPoint[1])
							{
								if(map[safeC(i-1)][safeC(j)].elevation <= .8)
								{
									map[safeC(i-1)][safeC(j)].elevation = .2; console.log("hi");
								}
							}
							if(safeC(j) < centerPoint[0]) //Left
							{
								if(map[safeC(i)][safeC(j+1)].elevation <= .8)
								{
									map[safeC(i)][safeC(j+1)].elevation = .2; console.log("hi");
								}
							}
							else if(safeC(j) > centerPoint[0])
							{
								if(map[safeC(i)][safeC(j-1)].elevation <= .8)
								{
									map[safeC(i)][safeC(j-1)].elevation = .2; console.log("hi");	
								}
							}
						}
					}
				}
			}
		}
		genLand();
		drawEntireMap();

	</script>
</body>
</html>
