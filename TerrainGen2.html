<!DOCTYPE html>
<html>
<head>
	<canvas id = "leftBar" width="125" height="720" style = "position: absolute; left: 5px; border: 1px solid black;"></canvas>
	<canvas id = "map" width="840" height="720" style = "position: absolute; left: 135px; border: 1px solid black;"></canvas>
	<canvas id = "rightBar" width="540" height="720" style = "position: absolute; left: 980px; border: 1px solid black;"></canvas>
</head>
<body>
	<script>
		var c = document.getElementById("map");
		var ctx = c.getContext("2d");
		const MAPSIZE = 2000;
		var map = new Array(MAPSIZE);
		const MULTIH = .2;
		const MULTI = .2;
		const MULTIL = .08;
		
		//Classes: -----------------
		function Tile()
		{
			this.elevation = .1;
			this.type = 'g';
			this.checked = -1;
			this.building = [];
		}
		function City()
		{
		
		}
		function Noble()
		{
			this.name = "";
			this.skill = 0;
		}
		function Society(){
			this.levels = [];
		}
		//End Classes--------------
		
		
		for(i = 0; i < MAPSIZE; i++){
			map[i] = new Array(MAPSIZE);
			for(j = 0; j < MAPSIZE; j++){
				map[i][j] = new Tile();
			}
		}
		function getDist(y1, x1, y2, x2)
		{
			var dx = Math.abs(x2 - x1);
			var dy = Math.abs(y2 - y1);
			if (dx > MAPSIZE/2){
				dx = MAPSIZE - dx;
			}
			if (dy > MAPSIZE/2){
				dy = MAPSIZE - dy;
			}
			return Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
		}
		function genName(male){
			var mBegs = ["Le", "Ke", "Je", "Be", "Me", "Ko", "Ye", "E", "Cy", "Ce", "Ci", "A"];
			var mMids = ["k", "r", "ke", "re", "vin", "t", "s", "n"];
			var mEnds = ["os", "ih", "o", "it", "en", "in", "de", "des", "re", "ro", "ov", "us", "on"];
			
			var fBegs = ["Ke", "Ti", "Di", "De", "Li", "Ki", "Ve", "Al", "Ma", "Ni", "Ari", "A", "E", "So"];
			var fMids = ["r", "n", "c", "s", "r", "or", "ret", "ken"];
			var fEnds = ["a", "i", "ei", "is", "ia", "a", "iev", "ana"];
			if(male){
				return "" + mBegs[Math.floor(Math.random() * mBegs.length)] + "" + mMids[Math.floor(Math.random() * mMids.length)] + "" + mEnds[Math.floor(Math.random() * mEnds.length)];
			}
			else{
				return "" + fBegs[Math.floor(Math.random() * fBegs.length)] + "" + fMids[Math.floor(Math.random() * fMids.length)] + "" + fEnds[Math.floor(Math.random() * fEnds.length)];
			}
		}
		
		function drawElevationMap()
		{
			ctx.clearRect(0, 0, 840, 720);
			c.width = MAPSIZE;
			c.height = MAPSIZE;
			var lastElev = -1;
			var rgbGrass;
			var rgbBeach;
			for(i = 0; i < MAPSIZE; i++){
				for(j = 0; j < MAPSIZE; j++){
					if(map[i][j].elevation != lastElev){
						rgbGrass = (Math.floor((map[i][j].elevation * 200)));
						rgbBeach = 200 - (Math.floor((map[i][j].elevation * 100)));
						if(map[i][j].elevation <= 0){
							ctx.fillStyle = "blue";
						}
						else if(map[i][j].elevation < .05){
							ctx.fillStyle = "tan";
						}
						else if(map[i][j].elevation <= .1){
							ctx.fillStyle = "lightgreen";
						}
						else if(map[i][j].elevation <= .2){
							ctx.fillStyle = "green";
						}
						else if(map[i][j].elevation <= 0.4){
							ctx.fillStyle = "darkgreen";
						}	
						else if(map[i][j].elevation <= 0.6){
							ctx.fillStyle = "olive";
						}
						else if(map[i][j].elevation <= .8){
							ctx.fillStyle = "black";
						}
						else if(map[i][j].elevation <= 0.9){
							ctx.fillStyle = "grey";
						}
						else{
							ctx.fillStyle = "rgb(255, 255, 255)";
						}
						lastElev = map[i][j].elevation;
					}
					ctx.fillRect(j*1, i*1, 1, 1);
				}
			}
		}
		function drawEntireMap()
		{
			ctx.clearRect(0, 0, 840, 720);
			c.width = MAPSIZE;
			c.height = MAPSIZE;
			var lastType = 'w';
			var rgbGrass;
			var rgbBeach;
			for(i = 0; i < MAPSIZE; i++){
				for(j = 0; j < MAPSIZE; j++){
					if(map[i][j].type != lastType){
						rgbGrass = (Math.floor((map[i][j].type * 200)));
						rgbBeach = 200 - (Math.floor((map[i][j].type * 100)));
						if(map[i][j].type == 'w' || map[i][j].type == 'r'){
							ctx.fillStyle = "blue";
						}
						else if(map[i][j].type == 'g'){
							ctx.fillStyle = "rgb("+ 50 +","+ 200 +","+ 50 +")";
						}
						else{
							ctx.fillStyle = "rgb(255, 255, 255)";
						}
						lastType = map[i][j].type;
					}
					ctx.fillRect(j*1, i*1, 1, 1);
				}
			}
		}
		var yView = 0;
		var xView = 0;
		var zoom = 8;
		var drawDelta = true;
		var grid = false;
		function drawMap()
		{
			ctx.clearRect(0, 0, 840, 720);
			for(i = 0; i < Math.floor(720/(20-zoom)); i++){
				for(j = 0; j < Math.floor(840/(20-zoom)); j++){
					var yLook = safeC(i + yView);
					var xLook = safeC(j + xView);
					if(map[yLook][xLook].type == 'w' || map[yLook][xLook].type == 'r'){
						ctx.fillStyle = "blue";
					}
					else if(map[yLook][xLook].type == 'm'){
						ctx.fillStyle = "white";
					}
					else { ctx.fillStyle = "green"; }
					ctx.fillRect(Math.floor(j * (20-zoom)), Math.floor(i * (20-zoom)), (20-zoom), (20-zoom));
					if(grid){
						if(map[yLook][xLook].type == 'g' && zoom < 12){
							ctx.strokeStyle = "darkgrey";
							ctx.strokeRect(Math.floor(j * (20-zoom)), Math.floor(i * (20-zoom)), (20-zoom), (20-zoom));
						}
					}
				}
			}
		}
		var lands = [];
		function genWorld()
		{
			genOceans(7000000, 1);
			lands = slapIslands(15000);
			mountain(5000, 125);
			//mountain(50, 300);
			elevSpread();
			//rivers();
		}
		function mountain(rSize, rNum){
			var yC = Math.floor(Math.random() * MAPSIZE);
			var xC = Math.floor(Math.random() * MAPSIZE);
			var rS = 0;
			var rN = 0;
			var dir = 0;
			var lastDir = -1;
			while(rN < rNum)
			{
				if(rS == rSize)
				{
					rS = 0;
					rN++;
					yC = Math.floor(Math.random() * MAPSIZE);
					xC = Math.floor(Math.random() * MAPSIZE);
				}
					do{
						dir = Math.floor(Math.random()*8);
					}while(dir == lastDir);
					switch(dir){
						case 0: yC--; xC--; break;
						case 1: yC--; break;
						case 2: yC--; xC++; break;
						case 3: xC++; break;
						case 4: yC++; xC++; break;
						case 5: yC++; break;
						case 6: yC++; xC--; break;
						case 7: xC--; break;
					}
					yC = safeC(yC);
					xC = safeC(xC);
					if(map[yC][xC].type != 'w'){
						if(rS == 0){
							map[yC][xC].elevation = 1;
							map[yC][xC].type = 'm';
						}
						else {
							var max = 0;
							for(a = -1; a < 2; a++){
								for(b = -1; b < 2; b++){
									if(map[safeC(yC+a)][safeC(xC+b)].elevation > max){
										max = map[safeC(yC+a)][safeC(xC+b)].elevation;
									}
								}
							}
							var add = max + .005 - Math.random()*.01;
							if(add > 1){ add = 1; }
							map[yC][xC].elevation = add;
							map[yC][xC].type = 'm';
							if(dir < 4){
								lastDir = dir + 4;
							}
							else{
								lastDir = dir - 4;
							}
						}
					}
					else { rS = rSize-1; }
				rS++;
			}
		}
		function elevSpread(){
			for(m = 0; m < 4; m++){
				for(h = 0; h < 2; h++){
					var i = h*(MAPSIZE-1);
					while(i < MAPSIZE && i >= 0){
						var j = h*(MAPSIZE-1);
						while(j < MAPSIZE && j >= 0){
							var add = 0;
							var max = 0;
							if(map[i][j].elevation > 0){
								for(a = -1; a < 2; a++){
									for(b = -1; b < 2; b++){
										if(map[safeC(i+a)][safeC(j+b)].elevation > max){ max = map[safeC(i+a)][safeC(j+b)].elevation; }
										add += map[safeC(i+a)][safeC(j+b)].elevation/8;
									}
									if(add < 0){ map[i][j].elevation/=2; }
									else {
										if(max > .9){
											if(map[i][j].elevation < max){
												map[i][j].elevation = max * (.65 + .3*Math.random());
											}
										}
										else if(max > .7){
											map[i][j].elevation = max - Math.random()/6;
										}
										else if(max > .6){
											map[i][j].elevation = max - Math.random()/10;
										}
										else if(max > .4){
											map[i][j].elevation = max + .01 - Math.random()/10;
										}
										else if(max > .2){
											map[i][j].elevation = max * (.6 + .45*Math.random());
										}
										else{
											map[i][j].elevation = add * (.7 + .5*Math.random());
										}
									}
								}
							}
							if(h==0){j++;} else {j--;}
						}
						if(h==0){i++;} else {i--;}
					}
				}
			}
		}
		function rivers(){
			var counter = 0;
			function makeRiver(yC, xC){
				var spot = new Array(2);
				var stack = [];
				var stop = false;
				stack.push([yC, xC]);
				var lastDir = -1;
				while(stack.length > 0 && !stop && counter < 500){
					counter++;
					spot = stack.pop();
					var y = safeC(spot[0]);
					var x = safeC(spot[1]);
					yView = y - 10;
					xView = x - 10;
					if(map[y][x].type != 'w'){
						var min = map[y][x].elevation * 1.1;
						if(counter > 0){
							map[y][x].type = 'r';
							map[y][x].elevation = 0
						}
						var minDir = -1;
						if(map[safeC(y - 1)][x].elevation < min && lastDir != 0){
							min = map[safeC(y - 1)][x].elevation;
							minDir = 0;
						}
						if(map[y][safeC(1+x)].elevation < min && lastDir != 1){
							min = map[y][safeC(1+x)].elevation;
							minDir = 1;
						}
						if(map[safeC(y + 1)][x].elevation < min && lastDir != 2){
							min = map[safeC(y + 1)][x].elevation;
							minDir = 2;
						}
						if(map[y][safeC(x-1)].elevation < min && lastDir != 3){
							min = map[y][safeC(x-1)].elevation;
							minDir = 3;
						}
						if(min > 0){
							if(minDir == 0){ stack.push([y-1, x]); }
							else if(minDir == 1){ stack.push([y, x+1]); }
							else if(minDir == 2){ stack.push([y+1, x]); }
							else { stack.push([y, x-1]); }
							if(minDir < 2){ lastDir = minDir+2;} else { lastDir = minDir -2; }
						}
						else { stop = true; }
					}
					else { stop = true; }
				}
			}
			for(i = 0; i < MAPSIZE; i++){
				for(j = 0; j < MAPSIZE; j++){
					if(map[i][safeC(j)].elevation > .45 && map[i][safeC(j-1)].elevation < .452){
						counter = 0;
						makeRiver(i, j);
						//console.log(counter);
					}
				}
			}
		}
		function safeC(a)
		{
			if(a >= MAPSIZE){
				return a%MAPSIZE;
			}
			else if(a < 0){
				return safeC(a+MAPSIZE);
			}
			return a;
		}
		function genOceans(oceanSize, numOceans)
		{
			var oS = oceanSize;
			var nO = numOceans;
			var dir = 0;
			var lastDir = 0;
			var yCoord = Math.floor(Math.random() * MAPSIZE);
			var xCoord = Math.floor(Math.random() * MAPSIZE);
			while(oS > 0 && nO > 0)
			{
				if(oS == 1)
				{
					oS = oceanSize; //Ocean size is too small, go to new location to begin making ocean
					yCoord = Math.floor(Math.random() * MAPSIZE);
					xCoord = Math.floor(Math.random() * MAPSIZE);
					nO--;
				}
				else
				{
					yCoord = safeC(yCoord);
					xCoord = safeC(xCoord);
					map[yCoord][xCoord].type = 'w';
					map[yCoord][xCoord].elevation = -1;
					do{
						dir = Math.floor(Math.random()*4);
					}while(dir == lastDir);
					if(dir == 0){ yCoord++; }
					else if(dir == 1){ xCoord++; }
					else if(dir == 2){ yCoord--; }
					else { xCoord--; }
					if(lastDir < 2){ lastDir = dir + 2} else { lastDir = dir - 2; } //Asign Last Dir
					oS--;
				}
			}
		}
		function slapIslands(size){
			var ind = 0;
			var counter = 0;
			var stack = [];
			var continents = [];
			function checkValidity(y, x, checking){
				var a = map[safeC(y)][safeC(x)];
				return (a.checked == -1 || !checking) && a.type == 'g';
			}
			function slapIslandsInner(yC, xC, index, checking){
				var spot = new Array(2);
				stack.push([yC, xC]);
				while(stack.length > 0){
					counter++;
					spot = stack.pop();
					y = safeC(spot[0]);
					x = safeC(spot[1]);
					if(checking){ map[y][x].checked = index; }
					else { map[y][x].type = 'w'; map[y][x].elevation = -1;}
					if(checkValidity(y+1, x, checking)){
						stack.push([y+1, x]);
						if(checking){ map[safeC(y+1)][safeC(x)].checked = index; }
						else { map[safeC(y+1)][safeC(x)].type = 'w'; map[y][x].elevation = -1;}
					}
					if(checkValidity(y, x+1, checking)){
						stack.push([y, x+1]);
						if(checking){ map[safeC(y)][safeC(x+1)].checked = index; }
						else { map[safeC(y)][safeC(x+1)].type = 'w';map[y][x].elevation = -1; }
					}
					if(checkValidity(y-1, x, checking)){
						stack.push([y-1, x]);
						if(checking){ map[safeC(y-1)][safeC(x)].checked = index; }
						else { map[safeC(y-1)][safeC(x)].type = 'w'; map[y][x].elevation = -1;}
					}
					if(checkValidity(y, x-1, checking)){
						stack.push([y, x-1]);
						if(checking){ map[safeC(y)][safeC(x-1)].checked = index; }
						else { map[safeC(y)][safeC(x-1)].type = 'w'; map[y][x].elevation = -1;}
					}
				}
			}
			for(i = 0; i < MAPSIZE; i++){
				for(j = 0; j < MAPSIZE; j++){
					if(checkValidity(i, j, true)){
						counter = 0;
						slapIslandsInner(i, j, ind++, true);
						if(counter < size){
							ind--;
							slapIslandsInner(i, j, ind, false);
						}
						else{
							continents[ind] = counter;
						}
					}
				}
			}
			return continents;
		}
		function mapV(event){
			if(event.keyCode == 37){
				xView--;
				drawDelta = true;	
			}
			else if(event.keyCode == 38){
				yView--;
				drawDelta = true;
			}
			else if(event.keyCode == 39){
				xView++;
				drawDelta = true;
			}
			else if(event.keyCode == 40){
				yView++;
				drawDelta = true;
			}
			else { drawDelta = false; }
		}
		
		genWorld();
		//drawEntireMap();
		drawElevationMap();
		for(i = 0; i < MAPSIZE; i++){ for(j = 0; j < MAPSIZE; j++){ if(map[i][j].type == 'g'){ yView = i; xView = j; i = MAPSIZE; j = i; }}}
		setInterval(function(){
			document.addEventListener('keydown', mapV);
			if(drawDelta){
				//drawMap();
			}
		}, 36);

	</script>
</body>
</html>